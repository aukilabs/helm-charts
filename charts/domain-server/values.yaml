containerImage:
  pullPolicy: IfNotPresent
  repository: aukilabs/domain-server
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""
applicationName: domain-server
forceStatefulSet: false
tolerations:
  - key: "dedicated"
    value: "armGroup"
    effect: "NoSchedule"
containerPorts:
  http:
    port: 8080
    protocol: TCP
  admin:
    port: 18190
    protocol: TCP
service:
  enabled: true
  ports:
    http:
      port: 8080
      targetPort: 8080
      protocol: TCP
    admin:
      port: 18190
      targetPort: 18190
      protocol: TCP
# affinity:
#   podAntiAffinity:
#     requiredDuringSchedulingIgnoredDuringExecution:
#       - labelSelector:
#           matchExpressions:
#             - key: app.kubernetes.io/name
#               operator: In
#               values:
#                 - domain-server-s3
#         topologyKey: kubernetes.io/hostname
ingress:
  enabled: false
  # className: nginx
  annotations:
    # kubernetes.io/tls-acme: "true"

    # CORS is needed for backup/restore functionality to work,
    # make sure to configure this for whatever ingress provider you use.
    nginx.ingress.kubernetes.io/enable-cors: "true"

    # Increase proxy body size to allow for large domain data uploads (or backup restores).
    nginx.ingress.kubernetes.io/proxy-body-size: "10G"
  path: /
  pathType: Prefix
  servicePort: http
  # hosts:
  #   - chart-example.local
  # tls:
  #   - secretName: chart-example-tls
  #     hosts:
  #       - chart-example.local
envVars:
  DS_ADDR: ":8080"
  DS_ADMIN_ADDR: ":18190"
  DS_POSTGRES_TRACE_LEVEL: "none"
  DS_PUBLIC_URL: "https://domain-server.example.com"
  DS_LOG_LEVEL: "info"
  DS_OPERATION_MODE: "public"
  DS_STORAGE_LOCAL_PATH: "./data/domain-data"
  DS_WALLET_PRIVATE_KEY_FILE_PATH: "/private-key-volume/wallet-private.key"
#  DS_POSTGRES_POOL_SIZE: "40" # Reference value for a database instance with 8 vCPUs
#  DS_ENABLE_EVENTS_UPLOADING: "false" # Event uploading can optionally be disabled here to increase performance
#  DS_DEFAULT_REQUEST_TIMEOUT: "600s" # 10 minutes
#  DS_STREAM_REQUEST_TIMEOUT: "600s" # 10 minutes
#  DS_RECONSTRUCTION_SERVER_URL: "https://reconstruction-server.example.com"
secrets:
  domain-server:
    as: environment
    items:
      postgres_url:
        envVarName: DS_POSTGRES_URL
      registration_credentials:
        envVarName: DS_REGISTRATION_CREDENTIALS
      # reconstruction_server_api_key:
      #   envVarName: DS_RECONSTRUCTION_SERVER_API_KEY
  private-key-volume:
    as: volume
    mountPath: /private-key-volume
    readOnly: true
    items:
      wallet-private.key:
        filePath: wallet-private.key

containerResources:
  limits:
    memory: 256Mi
  requests:
    memory: 256Mi
    cpu: 1
monitoring:
  namespace: monitoring
  podMonitor:
    create: false
    scrapeInterval: 10s

useExistingSecret: false
existingSecretName: ""
secretFile:
  privateKey: ""
  postgresUrl: "postgres://domain-server:domain-server@domain-server-postgresql:5432/domain-server?sslmode=disable"
  registrationCredentials: "MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwOmludmFsaWQ="
emptyDir:
  sizeLimit: "8Gi"
persistentVolume:
  ## If true, create/use a Persistent Volume Claim
  ## If false, use emptyDir
  ##
  enabled: true

  ## If set it will override the name of the created persistent volume claim
  ## generated by the stateful set.
  ##
  statefulSetNameOverride: ""

  ## Persistent Volume access modes
  ## Must match those of existing PV or dynamic provisioner
  ## Ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  accessModes:
    - ReadWriteOnce

  ## Persistent Volume labels
  ##
  labels: {}

  ## Persistent Volume annotations
  ##
  annotations: {}

  ## Persistent Volume existing claim name
  ## Requires server.persistentVolume.enabled: true
  ## If defined, PVC must be created manually before volume will be bound
  existingClaim: ""

  ## Persistent Volume size
  ##
  size: 20Gi

  ## Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # storageClass: "-"

  ## Persistent Volume Binding Mode
  ## If defined, volumeBindingMode: <volumeBindingMode>
  ## If undefined (the default) or set to null, no volumeBindingMode spec is
  ##   set, choosing the default mode.
  ##
  # volumeBindingMode: ""

  ## Path Persistent Volume to mount
  mountPath: "/app/data/domain-data"
  subPath: ""

  ## Persistent Volume Claim Selector
  ## Useful if Persistent Volumes have been provisioned in advance
  ## Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector
  ##
  # selector:
  #  matchLabels:
  #    release: "stable"
  #  matchExpressions:
  #    - { key: environment, operator: In, values: [ dev ] }

  ## Persistent Volume Name
  ## Useful if Persistent Volumes have been provisioned in advance and you want to use a specific one
  ##
  # volumeName: ""

postgresql:
  # If true, the PostgreSQL dependency is enabled
  enabled: true
  global:
    postgresql:
      auth:
        username: domain-server
        password: domain-server
        database: domain-server
  primary:
    networkPolicy:
      enabled: false
  fullnameOverride: "domain-server-postgresql"

securityContext:
  fsGroup: 101
  runAsGroup: 101
  runAsUser: 100

juicefs-s3-gateway:
  enabled: false
  replicaCount: 3
  image:
    # https://github.com/juicedata/juicefs/releases
    tag: "ce-v1.2.4"
  envs:
    - name: AZURE_STORAGE_CONNECTION_STRING
      # WARNING: This is a placeholder value. You MUST replace "REPLACE_WITH_ACTUAL_AZURE_STORAGE_CONNECTION_STRING"
      # with your actual Azure Storage connection string before deploying to production.
      value: "REPLACE_WITH_ACTUAL_AZURE_STORAGE_CONNECTION_STRING"
  secret:
    enabled: true
    name: "domain-server"
    metaurl: "rediss://:REPLACE_ME_REDIS_PASSWORD=@REPLACE_ME_REDIS_NAME.redis.cache.windows.net:6380/0"
    storage: "wasb"
    accessKey: "GET_FROM_AZURE"
    secretKey: "GET_FROM_AZURE"
    bucket: "https://<abs_name>.core.windows.net"
#  affinity:
#    podAntiAffinity:
#      requiredDuringSchedulingIgnoredDuringExecution:
#        - labelSelector:
#            matchExpressions:
#              - key: app.kubernetes.io/name
#                operator: In
#                values:
#                  - juicefs-s3-gateway
#          topologyKey: kubernetes.io/hostname
#

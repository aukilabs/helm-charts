containerImage:
  pullPolicy: IfNotPresent
  repository: aukilabs/domain-server
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

applicationName: domain-server

# kind can be StatefulSet or Deployment
# Deployment requires an S3-compatible storage backend to be configured unless
# your PVC supports mounting from multiple pods. If using S3 storage, we
# recommend also enabling juicefs-s3-gateway for caching. With JuiceFS, other
# non-S3 backends can be used, such as Azure Blob Storage. See the juicefs-s3-gateway
# section below.
kind: StatefulSet

# only applicable for Deployment kind
replicaCount: 2

tolerations:
  - key: "dedicated"
    value: "armGroup"
    effect: "NoSchedule"

containerPorts:
  http:
    port: 8080
    protocol: TCP
  admin:
    port: 18190
    protocol: TCP

service:
  enabled: true
  ports:
    http:
      port: 8080
      targetPort: 8080
      protocol: TCP
    admin:
      port: 18190
      targetPort: 18190
      protocol: TCP

# affinity:
#   podAntiAffinity:
#     requiredDuringSchedulingIgnoredDuringExecution:
#       - labelSelector:
#           matchExpressions:
#             - key: app.kubernetes.io/name
#               operator: In
#               values:
#                 - domain-server-s3
#         topologyKey: kubernetes.io/hostname

ingress:
  enabled: false
  # className: nginx
  annotations:
    # kubernetes.io/tls-acme: "true"

    # CORS is needed for backup/restore functionality to work,
    # make sure to configure this for whatever ingress provider you use.
    nginx.ingress.kubernetes.io/enable-cors: "true"

    # Increase proxy body size to allow for large domain data uploads (or backup restores).
    nginx.ingress.kubernetes.io/proxy-body-size: "10G"
  path: /
  pathType: Prefix
  servicePort: http
  # hosts:
  #   - chart-example.local
  # tls:
  #   - secretName: chart-example-tls
  #     hosts:
  #       - chart-example.local

envVars:
  DS_ADDR: ":8080"
  DS_ADMIN_ADDR: ":18190"
  DS_POSTGRES_TRACE_LEVEL: "none"
  DS_PUBLIC_URL: "https://domain-server.example.com"
  DS_LOG_LEVEL: "info"
  DS_OPERATION_MODE: "public"
  DS_STORAGE_LOCAL_PATH: "./data/domain-data"
  DS_WALLET_PRIVATE_KEY_FILE_PATH: "/private-key-volume/wallet-private.key"
#  DS_POSTGRES_POOL_SIZE: "40" # Reference value for a database instance with 8 vCPUs
#  DS_ENABLE_EVENTS_UPLOADING: "false" # Event uploading can optionally be disabled here to increase performance
#  DS_DEFAULT_REQUEST_TIMEOUT: "600s" # 10 minutes
#  DS_STREAM_REQUEST_TIMEOUT: "600s" # 10 minutes
#  DS_RECONSTRUCTION_SERVER_URL: "https://reconstruction-server.example.com"

secrets:
  domain-server:
    as: environment
    items:
      postgres_url:
        envVarName: DS_POSTGRES_URL
      registration_credentials:
        envVarName: DS_REGISTRATION_CREDENTIALS
      # reconstruction_server_api_key:
      #   envVarName: DS_RECONSTRUCTION_SERVER_API_KEY
  private-key-volume:
    as: volume
    mountPath: /private-key-volume
    readOnly: true
    items:
      wallet-private.key:
        filePath: wallet-private.key

# These are the recommended minimums but feel free to adjust based on your expected load.
containerResources:
  limits:
    memory: 256Mi
  requests:
    memory: 256Mi
    cpu: 1
    # We recommend setting this to the same as emptyDir.sizeLimit if persistentVolume.enabled=false
    # ephemeral-storage: 20Gi

monitoring:
  namespace: monitoring
  podMonitor:
    create: false
    scrapeInterval: 10s

useExistingSecret: false
existingSecretName: ""
secretFile:
  privateKey: ""
  postgresUrl: "postgres://domain-server:domain-server@domain-server-postgresql:5432/domain-server?sslmode=disable"
  registrationCredentials: "MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwOmludmFsaWQ="
emptyDir:
  sizeLimit: "20Gi"
persistentVolume:
  ## If true, create/use a Persistent Volume Claim
  ## If false, use emptyDir
  ## We recommend using persistent volumes even for S3 storage because when
  ## domain backups are restored, they first need to be stored locally.
  ## The alternative is to have enough of ephemeral storage on the K8s node
  ## running the domain-server and use emptyDir.
  ##
  enabled: true

  ## If set it will override the name of the created persistent volume claim.
  ##
  nameOverride: ""

  ## Persistent Volume access modes
  ## Must match those of existing PV or dynamic provisioner
  ## Ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  accessModes:
    - ReadWriteOnce

  ## Persistent Volume labels
  ##
  labels: {}

  ## Persistent Volume annotations
  ##
  annotations: {}

  ## Persistent Volume existing claim name
  ## Requires server.persistentVolume.enabled: true
  ## If defined, PVC must be created manually before volume will be bound
  existingClaim: ""

  ## Persistent Volume size
  ##
  size: 20Gi

  ## Storage Class Configuration
  ## ---------------------------
  ## 1. Default: If commented out or null, the cluster's default StorageClass is used.
  ##    (Common: AWS 'gp3', GKE 'standard-rwo', Azure 'managed-csi')
  ##
  ## 2. Specific Class: Set to a named class for specific IOPS/throughput.
  ##    Example: storageClass: "gp3" or "premium-rwo"
  ##
  ## 3. Manual Provisioning: Set to an empty string ("") to disable dynamic
  ##    provisioning. Use this if you have manually created Persistent Volumes (PVs).
  ##
  # storageClass: ""

  ## Persistent Volume Binding Mode
  ## If defined, volumeBindingMode: <volumeBindingMode>
  ## If undefined (the default) or set to null, no volumeBindingMode spec is
  ##   set, choosing the default mode.
  ##
  # volumeBindingMode: ""

  ## Path Persistent Volume to mount
  mountPath: "/app/data/domain-data"
  subPath: ""

  ## Persistent Volume Claim Selector
  ## Useful if Persistent Volumes have been provisioned in advance
  ## Ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector
  ##
  # selector:
  #  matchLabels:
  #    release: "stable"
  #  matchExpressions:
  #    - { key: environment, operator: In, values: [ dev ] }

  ## Persistent Volume Name
  ## Useful if Persistent Volumes have been provisioned in advance and you want to use a specific one
  ##
  # volumeName: ""

## Autoscaling configuration
## ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
autoscaling:
  vpa:
    enabled: false
    annotations: {}
    ## List of resources that the vertical pod autoscaler can control. Defaults to cpu and memory
    ##
    controlledResources: []
    ## Max allowed resources for the pod
    ## cpu: 200m
    ## memory: 100Mi
    maxAllowed: {}
    ## Min allowed resources for the pod
    ## cpu: 200m
    ## memory: 100Mi
    minAllowed: {}
    ## VPA update policy
    ##
    updatePolicy:
      ## Autoscaling update policy Specifies whether recommended updates are applied when a Pod is started and whether recommended updates are applied during the life of a Pod
      ## Possible values are "Off", "Initial", "Recreate", and "Auto".
      ##
      updateMode: Auto
  hpa:
    enabled: false
    annotations: {}
    minReplicas: ""
    maxReplicas: ""
    ## Target CPU utilization percentage
    ##
    targetCPU: ""
    ## Target Memory utilization percentage
    ##
    targetMemory: ""

# See https://github.com/bitnami/charts/blob/postgresql/16.7.27/bitnami/postgresql/values.yaml
postgresql:
  # If true, the PostgreSQL dependency is enabled
  enabled: true
  image:
    # https://github.com/bitnami/containers/issues/83267
    repository: bitnamilegacy/postgresql
  global:
    postgresql:
      auth:
        username: domain-server
        password: domain-server
        database: domain-server
  primary:
    networkPolicy:
      enabled: false
  fullnameOverride: "domain-server-postgresql"

securityContext:
  fsGroup: 101
  runAsGroup: 101
  runAsUser: 100

containerSecurityContext:
  privileged: false
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

# See https://github.com/juicedata/charts/blob/helm-chart-juicefs-s3-gateway-0.11.3/charts/juicefs-s3-gateway/values.yaml
juicefs-s3-gateway:
  enabled: false
